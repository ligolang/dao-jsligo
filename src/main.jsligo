#import "./constants.jsligo" "Constants"
#import "./errors.jsligo" "Errors"
#import "./lambda.jsligo" "Lambda"
#import "./outcome.jsligo" "Outcome"
#import "./proposal.jsligo" "Proposal"
#import "./storage.jsligo" "Storage"
#import "./vote.jsligo" "Vote"
#import "./token.jsligo" "Token"
#import "./vault.jsligo" "Vault"
#import "./timelock.jsligo" "Timelock"

export type storage = Storage.t;
type result = [list<operation>, storage];
type parameter = [nat, bytes]

@entry
const execute = (p: parameter, s: storage) : result => {
    const [outcomeKey, packed] = p;
    const proposal = match(Big_map.find_opt(outcomeKey, s.outcomes)) {
        when(None()) : failwith(Errors.outcomeNotFound);
        when(Some(o)) : Outcome.getExecutableProposal(o);
    };

    Timelock._checkUnlocked(proposal.timelock);
    const lambda_ : Lambda.t = Lambda.unpack(proposal.hash, packed);

    return match(lambda_) {
        when(OperationList(f)) : [
            f(),
            Storage.updateOutcome(outcomeKey, [proposal, Executed()], s)
        ];
        when(ParameterChange(f)) : [
            Constants.noOperation,
            Storage.updateOutcome(
                outcomeKey,
                [proposal, Executed()],
                Storage.updateConfig(f,s)
            )]
    };
};

@entry
const propose = (p: Proposal.makeParams, s: storage) : result =>
    match(s.proposal) {
        when(Some(_)) : failwith(Errors.proposalAlreadyExists);
        when(None()) : [
            list([Token.transfer(
                [s.governanceToken,
                Tezos.get_sender(),
                Tezos.get_self_address(),
                s.config.depositAmount]
            )]), Storage.createProposal(
                Proposal.make(p, s.config.startDelay, s.config.votingPeriod),
                s)
        ]
    };

@entry
const cancel = (outcomeKeyOpt: option<nat>, s: storage) : result =>
   [list([Token.transfer(
        [s.governanceToken,
        Tezos.get_self_address(),
        s.config.burnAddress,
        s.config.depositAmount])
   ]), match(outcomeKeyOpt) {
        when(None()) : match(s.proposal) {
            when(None()) : failwith(Errors.nothingToCancel);
            when(Some(p)) : do {
                Proposal._checkNotVotingPeriod(p);
                assert_with_error(
                    p.creator == Tezos.get_sender(),
                    Errors.notCreator
                );

                return Storage.addOutcome([p, Canceled()], s);
            }};
        when(Some(outcomeKey)) : match(Big_map.find_opt(outcomeKey, s.outcomes)) {
            when(None()) : failwith(Errors.outcomeNotFound);
            when(Some(o)) : do {
                const [p, state] = o;
                assert_with_error(
                    p.creator == Tezos.get_sender(),
                    Errors.notCreator
                );
                assert_with_error(
                    state != (Executed() as Outcome.state),
                    Errors.alreadyExecuted
                );
                Timelock._checkLocked(p.timelock);

                return Storage.updateOutcome(outcomeKey, [p, Canceled()], s)
            }};
        }
   ];

@entry
const lock = (amount_: nat, s: storage) : result => {
    Proposal._checkNoVoteOngoing(s.proposal);
    const currentAmount = Vault.getForUser([s.vault, Tezos.get_sender()]);

    return [
        list([Token.transfer(
            [s.governanceToken,
            Tezos.get_sender(),
            Tezos.get_self_address(), amount_])]),
        Storage.updateVault(Vault.updateForUser(
            [s.vault,
            Tezos.get_sender(),
            currentAmount + amount_]), s)
    ];
};

@entry
const release = (amount_: nat, s: storage) : result => {
    Proposal._checkNoVoteOngoing(s.proposal);
    const currentAmount = Vault.getForUserExn([s.vault, Tezos.get_sender()]);
    assert_with_error( (currentAmount >= amount_), Errors.notEnoughBalance);

    return [
        list([Token.transfer(
            [s.governanceToken,
            Tezos.get_self_address(),
            Tezos.get_sender(), amount_])]),
        Storage.updateVault(Vault.updateForUser(
            [s.vault,
            Tezos.get_sender(),
            abs(currentAmount - amount_)]), s)
    ];
};

@entry
const vote = (choice: bool, s: storage) : storage =>
    match(s.proposal) {
        when(None()) : failwith(Errors.noProposal);
        when(Some(p)) : do {
            Proposal._checkIsVotingPeriod(p);
            const amount_ = Vault.getForUserExn([s.vault, Tezos.get_sender()]);
            return Storage.updateVotes(p, [choice, amount_], s);
        }};

@entry
const endVote = (_ : unit, s: storage) : result =>
    match(s.proposal) {
        when(None()) : failwith(Errors.noProposal);
        when(Some(p)) : do {
            Proposal._checkVotingPeriodEnded(p);
            const totalSupply = 
                match(Token.getTotalSupply(s.governanceToken)) {
                when (None()) : failwith(Errors.fa2TotalSupplyNotFound);
                when (Some(n)) : n;
            };
            const outcome = Outcome.make(
                    p,
                    totalSupply,
                    s.config.refundThreshold,
                    s.config.quorumThreshold,
                    s.config.superMajority
                );
            const [_, state] = outcome;

            let transferToAddr = p.creator;
            if (Rejected_(WithoutRefund()) == state) {
                transferToAddr = s.config.burnAddress;
            }
            return [
                list([Token.transfer(
                    [s.governanceToken,
                    Tezos.get_self_address(),
                    transferToAddr,
                    s.config.depositAmount])])
                , Storage.addOutcome(outcome, s)
            ];
        }};