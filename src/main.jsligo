#import "./constants.jsligo" "Constants"
#import "./errors.jsligo" "Errors"
#import "./lambda.jsligo" "Lambda"
#import "./outcome.jsligo" "Outcome"
#import "./proposal.jsligo" "Proposal"
#import "./storage.jsligo" "Storage"
#import "./vote.jsligo" "Vote"
#import "./token.jsligo" "Token"
#import "./vault.jsligo" "Vault"
#import "./timelock.jsligo" "Timelock"

export type parameter =
    // @layout:comb
    | ["Propose", Proposal.makeParams]
    | ["Cancel", option<nat>]
    | ["Lock", Vault.amount_]
    | ["Release", Vault.amount_]
    | ["Execute", Outcome.executeParams]
    | ["Vote", Vote.choice]
    | ["EndVote"]
;

export type storage = Storage.t;
type result = [list<operation>, storage];

@entry
const execute = (outcomeExecuteParam : Outcome.executeParams, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    const {outcomeKey, packed} = outcomeExecuteParam;
    const proposal = match(Big_map.find_opt(outcomeKey, s.outcomes)) {
        when(None): failwith(Errors.outcomeNotFound);
        when(Some(outcome)): Outcome.getExecutableProposal(outcome)
    };

    Timelock._checkUnlocked(proposal.timelock);
    const lambda_ : Lambda.t = Lambda.unpack(proposal.hash, packed);

    return match(lambda_) {
        when(OperationList(f)): [
            f(),
            Storage.updateOutcome(outcomeKey, [proposal, Executed()], s)
        ];
        when(ParameterChange(f)): [
            Constants.noOperation,
            Storage.updateOutcome(
                outcomeKey,
                [proposal, Executed()],
                Storage.updateConfig(f,s)
            )
        ]
    };
};

@entry
const propose = (p: Proposal.makeParams, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    match(s.proposal) {
        when(Some(_proposal)): failwith(Errors.proposalAlreadyExists);
        when(None): [
            list([Token.transfer(
                [s.governanceToken,
                Tezos.get_sender(),
                Tezos.get_self_address(),
                s.config.depositAmount]
            )]), Storage.createProposal(
                Proposal.make(p, s.config.startDelay, s.config.votingPeriod),
                s)
        ]
    }
};

@entry
const cancel = (outcomeKeyOpt: option<nat>, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    return [
        list([
            Token.transfer([
                s.governanceToken,
                Tezos.get_self_address(),
                s.config.burnAddress,
                s.config.depositAmount
            ])
        ]),
        match(outcomeKeyOpt) {
            when(None):
                match(s.proposal) {
                    when(None): failwith(Errors.nothingToCancel);
                    when(Some(proposal)): do {
                        Proposal._checkNotVotingPeriod(proposal);
                        assert_with_error(
                            proposal.creator == Tezos.get_sender(),
                            Errors.notCreator
                        );

                        return Storage.addOutcome([proposal, Canceled()], s);
                    }
                };
            when(Some(outcomeKey)):
                match(Big_map.find_opt(outcomeKey, s.outcomes)) {
                    when(None): failwith(Errors.outcomeNotFound);
                    when(Some(outcome)): do {
                        const [p, state] = outcome;
                        assert_with_error(
                            p.creator == Tezos.get_sender(),
                            Errors.notCreator
                        );
                        assert_with_error(
                            state != (Executed() as Outcome.state),
                            Errors.alreadyExecuted
                        );
                        Timelock._checkLocked(p.timelock);

                        return Storage.updateOutcome(outcomeKey, [p, Canceled()], s)
                    }
                }
        }
   ]
};

@entry
const lock = (amount_: nat, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    Proposal._checkNoVoteOngoing(s.proposal);
    const currentAmount = Vault.getForUser([s.vault, Tezos.get_sender()]);

    return [
        list([Token.transfer(
            [s.governanceToken,
            Tezos.get_sender(),
            Tezos.get_self_address(), amount_])]),
        Storage.updateVault(Vault.updateForUser(
            [s.vault,
            Tezos.get_sender(),
            currentAmount + amount_]), s)
    ];
};

@entry
const release = (amount_: nat, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    Proposal._checkNoVoteOngoing(s.proposal);
    const currentAmount = Vault.getForUserExn([s.vault, Tezos.get_sender()]);
    assert_with_error( (currentAmount >= amount_), Errors.notEnoughBalance);

    return [
        list([Token.transfer(
            [s.governanceToken,
            Tezos.get_self_address(),
            Tezos.get_sender(), amount_])]),
        Storage.updateVault(Vault.updateForUser(
            [s.vault,
            Tezos.get_sender(),
            abs(currentAmount - amount_)]), s)
    ];
};

@entry
const vote = (choice: bool, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    return [
        Constants.noOperation,
        match(s.proposal) {
            when(None): failwith(Errors.noProposal);
            when(Some(proposal)): do {
                Proposal._checkIsVotingPeriod(proposal);
                const amount_ = Vault.getForUserExn([s.vault, Tezos.get_sender()]);
                return Storage.updateVotes(proposal, [choice, amount_], s);
            }
        }
    ]
};

@entry
const endVote = (_u : unit, s: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    return match(s.proposal) {
        when(None): failwith(Errors.noProposal);
        when(Some(proposal)): do {
            Proposal._checkVotingPeriodEnded(proposal);
            const totalSupply = match(Token.getTotalSupply(s.governanceToken)) {
                when(None): failwith(Errors.fa2TotalSupplyNotFound);
                when(Some(n)): n
            };
            const outcome = Outcome.make(
                    proposal,
                    totalSupply,
                    s.config.refundThreshold,
                    s.config.quorumThreshold,
                    s.config.superMajority
                );
            const [_, state] = outcome;

            let transferToAddr = proposal.creator;
            if (Rejected_(WithoutRefund()) == state) {
                transferToAddr = s.config.burnAddress;
            }
            return [
                list([Token.transfer(
                    [s.governanceToken,
                    Tezos.get_self_address(),
                    transferToAddr,
                    s.config.depositAmount])])
                , Storage.addOutcome(outcome, s)
            ];
        }
    }
};