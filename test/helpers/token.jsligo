#import "@ligo/fa/lib/fa2/asset/single_asset.impl.mligo" "SingleAsset"
#import "@ligo/fa/test/fa2/single_asset.test.mligo" "SingleAsset_helper"
#import "@ligo/fa/lib/fa2/common/tzip12.datatypes.jsligo" "TZIP12"
#import "./assert.jsligo" "Assert"
#import "../../src/main.jsligo" "DAO"

// Some types for readability
export type originated<p, s> = {
    addr: address,
    taddr: typed_address<p, s>,
    owners: list<address>,
    ops: list<address>
};

export const originate = (tok_amount : nat) => {
    const f = "../bootstrap/single_asset.mligo";
    const [init_storage, owners, ops] = SingleAsset_helper.get_initial_storage(
        [tok_amount, tok_amount, tok_amount]
    );
    const orig = Test.originate_from_file(f, init_storage, 0 as tez);
    const taddr = orig.addr;
    const addr = Test.to_address(taddr);
    return {
        addr: addr,
        taddr: taddr,
        owners: owners,
        ops: ops
    };
};

type single_asset_transfer_param = {
    source: address,
    from_: address,
    to: address,
    amount: nat
};

// Transfer token in [contr] between [from_] and [to_] addresses with [amount_] tokens,
//  WARNING: changes Test framework source
// const transfer = (s : DAO.storage, from_: address, to_: address, amount_: nat)
// : nat => {
//     Test.set_source (from_);
//     const transfer_requests : TZIP12.transfer = list([
//       {
//         from_: from_, 
//         txs: list([{to_:to_, amount: amount_, token_id: 0 as nat}])
//       }
//     ]);
//     let [ops, store] = Transfer([transfer_requests, s]) as parameter_of SingleAsset.SingleAsset;
//     0 as nat
// };

// Batch add [operators] to [contr] contract
const add_operators = (owners: list<address>, address : address, taddr) : unit => {
    const add_operator = (operators, owner, addr) => {
        Test.set_source(owner);
        return SingleAsset.Sidecar.add_operator(operators, owner, addr)
    };
    const operators : big_map<address, set<address>> = List.fold(
        (operators : SingleAsset.Datatypes.operators, owner: address) : SingleAsset.Datatypes.operators => {
            add_operator(operators, owner, address);
        }, 
        owners, 
        Big_map.empty
    );
    let r = Test.transfer(taddr, (Update_operators(operators) as list<TZIP12.update_operators>), 0 as tez);
    Assert.txSuccess(r);
};

// assert for FA2 insuffiscient balance string failure
// const assertInsBalanceFailure = (r : test_exec_result) : unit =>
//     Assert.stringFailure(r, SingleAsset.Errors.ins_balance);

// assert FA2 contract at [taddr] have [owner] address with [amount_] tokens in its ledger
// const assertBalanceAmount = (taddr, owner, amount_: nat) : unit => {
//     const s = Test.get_storage (taddr);
//     return match (Big_map.find_opt(owner, s.ledger)) {
//         when (Some(tokens)) : assert(tokens == amount_);
//         when (None()) : Test.failwith("Big_map key should not be missing")
//     };
// };

// get balance in [taddr] contract for [owner] address
// const get_balance_for<p, s> = (taddr : typed_address<p, s>, owner) :
// nat => {
//     const s = Test.get_storage (taddr);
//     return match (Big_map.find_opt(owner, s.ledger)) {
//         when (Some(amount_)) : amount_;
//         when (None()) : 0 as nat
//     };
// };

// Create a lambda of type (list<operation>) that would call the "transfer"
// entrypoint of a FA2 contract residing at [addr], making a token transfer between
// [from_] and [to_] addresses with [amount_] tokens.
// const createTransferCallable = (addr: address, from_: address, to_: address, amount_: nat)
// : DAO.Lambda.operationList => {
//         const transferOpt: option<contract<SingleAsset.transfer>> =
//             Tezos.get_entrypoint_opt("%transfer", addr);

//         return match (transferOpt) {
//             when (Some(c)) : do {
//                 const transfer_requests: SingleAsset.transfer = list([
//                   {from_: from_, txs: list([{to_: to_, amount: amount_, token_id: 0 as nat}]) as
//                   list<SingleAsset.atomic_trans> }
//                 ]);
//                 const op = Tezos.transaction(transfer_requests, 0 as tez, c);
//                 return list([op]);
//             };
//             when (None()) : failwith("TOKEN_CONTRACT_NOT_FOUND");
//         };
// };
