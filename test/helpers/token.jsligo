#import "@ligo/fa/lib/fa2/asset/single_asset.impl.jsligo" "SingleAsset"

#import "@ligo/fa/test/fa2/single_asset_jsligo.test.mligo" "SingleAsset_helper"

#import "./assert.jsligo" "Assert"

#import "../../src/main.jsligo" "DAO"

// Some types for readability

export type originated<p, s> = {
    addr: address,
    taddr: typed_address<p, s>,
    owners: list<address>,
    ops: list<address>
};

export const originate = (tok_amount: nat) => {
    const f = "../bootstrap/single_asset.mligo";
    const [init_storage, owners, ops] =
        SingleAsset_helper.get_initial_storage(
            [tok_amount, tok_amount, tok_amount]
        );
    const orig =
        Test.originate(
            contract_of(SingleAsset.SingleAsset),
            init_storage,
            0mutez
        );
    const taddr = orig.addr;
    const addr = Test.to_address(taddr);
    return { addr: addr, taddr: taddr, owners: owners, ops: ops };
};

type single_asset_transfer_param = {
    source: address,
    from_: address,
    to: address,
    amount: nat
};

// Transfer token in [contr] between [from_] and [to_] addresses with [amount_] tokens,
//  WARNING: changes Test framework source
export const transfer = (
    token_address: typed_address<
        parameter_of SingleAsset.SingleAsset,
        SingleAsset.SingleAsset.storage
    >, 
    from_: address, 
    to_: address, 
    amount_: nat 
): nat => {
    Test.set_source (from_);
    const transfer_requests : SingleAsset.TZIP12.transfer = list([
      {from_: from_, txs: list([{to_:to_, amount: amount_, token_id: 0 as nat}])}
    ]);
    return Test.transfer_exn (token_address, (Transfer(transfer_requests) as  parameter_of SingleAsset.SingleAsset), 0 as tez);
};

// Batch add [operators] to [contr] contract
export const add_operators = (
    operators: list<SingleAsset.Datatypes.operator>,
    token_address: typed_address<
        parameter_of SingleAsset.SingleAsset,
        SingleAsset.SingleAsset.storage
    >,
    daoAddress: address
): unit => {
    const f = (
        [operators, operator]: [
            list<SingleAsset.TZIP12.unit_update>,
            SingleAsset.Datatypes.operator
        ]
    ): list<SingleAsset.TZIP12.unit_update> =>
        list(
            [
                (
                    Add_operator(
                        {
                            owner: operator,
                            operator: daoAddress,
                            token_id: 0 as nat
                        }
                    ) as SingleAsset.TZIP12.unit_update
                ),
                ...operators
            ]
        );
    const add_operators =
        List.fold_left(
            f,
            (list([]) as list<SingleAsset.TZIP12.unit_update>),
            operators
        );
    const contr = Test.to_contract(token_address);
    let r =
        Test.transfer_to_contract(
            contr,
            (Update_operators(add_operators)),
            0 as tez
        );
    Assert.txSuccess(r);
};

// assert for FA2 insuffiscient balance string failure
// const assertInsBalanceFailure = (r : test_exec_result) : unit =>
//     Assert.stringFailure(r, SingleAsset.Errors.ins_balance);
// assert FA2 contract at [taddr] have [owner] address with [amount_] tokens in its ledger
// const assertBalanceAmount = (taddr, owner, amount_: nat) : unit => {
//     const s = Test.get_storage (taddr);
//     return match (Big_map.find_opt(owner, s.ledger)) {
//         when (Some(tokens)) : assert(tokens == amount_);
//         when (None()) : Test.failwith("Big_map key should not be missing")
//     };
// };
// get balance in [taddr] contract for [owner] address
// const get_balance_for<p, s> = (taddr : typed_address<p, s>, owner) :
// nat => {
//     const s = Test.get_storage (taddr);
//     return match (Big_map.find_opt(owner, s.ledger)) {
//         when (Some(amount_)) : amount_;
//         when (None()) : 0 as nat
//     };
// };
// Create a lambda of type (list<operation>) that would call the "transfer"
// entrypoint of a FA2 contract residing at [addr], making a token transfer between
// [from_] and [to_] addresses with [amount_] tokens.
// const createTransferCallable = (addr: address, from_: address, to_: address, amount_: nat)
// : DAO.Lambda.operationList => {
//         const transferOpt: option<contract<SingleAsset.transfer>> =
//             Tezos.get_entrypoint_opt("%transfer", addr);
//         return match (transferOpt) {
//             when (Some(c)) : do {
//                 const transfer_requests: SingleAsset.transfer = list([
//                   {from_: from_, txs: list([{to_: to_, amount: amount_, token_id: 0 as nat}]) as
//                   list<SingleAsset.atomic_trans> }
//                 ]);
//                 const op = Tezos.transaction(transfer_requests, 0 as tez, c);
//                 return list([op]);
//             };
//             when (None()) : failwith("TOKEN_CONTRACT_NOT_FOUND");
//         };
// };
